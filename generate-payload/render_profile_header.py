#!/usr/bin/env python3
"""Render validated profile artifacts into a generated C header."""

from __future__ import annotations

import argparse
import pathlib
import sys
from typing import List

from validate_profile import validate_profile


def _c_escape(text: str) -> str:
    return text.replace("\\", "\\\\").replace('"', '\\"')


def _render_header(profile: dict) -> str:
    header_lines: List[str] = []
    header_lines.append("#ifndef PROFILE_CONFIG_H")
    header_lines.append("#define PROFILE_CONFIG_H")
    header_lines.append("")
    header_lines.append("/* Generated by generate-payload/render_profile_header.py */")
    header_lines.append(f"#define PROFILE_ID \"{_c_escape(profile['profile_id'])}\"")
    header_lines.append(f"#define PROFILE_SCHEMA_VERSION \"{_c_escape(profile['schema_version'])}\"")
    header_lines.append(f"#define PROFILE_C2_SERVER \"{_c_escape(profile['host'])}\"")
    header_lines.append(f"#define PROFILE_C2_PORT {int(profile['port'])}")
    header_lines.append(f"#define PROFILE_C2_USE_HTTPS {1 if profile['use_https'] else 0}")
    header_lines.append(f"#define PROFILE_HTTP_GET_URI \"{_c_escape(profile['http_get_uri'])}\"")
    header_lines.append(f"#define PROFILE_HTTP_POST_URI \"{_c_escape(profile['http_post_uri'])}\"")
    header_lines.append(f"#define PROFILE_USER_AGENT \"{_c_escape(profile['user_agent'])}\"")

    rendered_headers: List[str] = []
    for key in sorted(profile["http_headers"].keys()):
        value = profile["http_headers"][key]
        rendered_headers.append(f"{key}: {value}")

    header_lines.append(f"#define PROFILE_HEADER_COUNT {len(rendered_headers)}")
    for idx, header in enumerate(rendered_headers):
        header_lines.append(f"#define PROFILE_HEADER_{idx} \"{_c_escape(header)}\"")

    header_lines.append("")
    header_lines.append("#endif /* PROFILE_CONFIG_H */")
    header_lines.append("")
    return "\n".join(header_lines)


def parse_args(argv: List[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Render generated profile header from JSON profile")
    parser.add_argument("--profile", required=True, type=pathlib.Path, help="Path to profile JSON")
    parser.add_argument("--output", required=True, type=pathlib.Path, help="Path to generated header output")
    parser.add_argument("--dry-run", action="store_true", help="Render without writing file")
    return parser.parse_args(argv)


def main(argv: List[str]) -> int:
    args = parse_args(argv)
    profile, errors = validate_profile(args.profile)
    if errors:
        for error in errors:
            print(f"INVALID {args.profile}: {error}")
        return 1

    rendered = _render_header(profile)

    if args.dry_run:
        print(rendered)
        print(f"DRY-RUN rendered profile header for {profile['profile_id']}")
        return 0

    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(rendered, encoding="utf-8")
    print(f"WROTE {args.output} profile_id={profile['profile_id']}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
