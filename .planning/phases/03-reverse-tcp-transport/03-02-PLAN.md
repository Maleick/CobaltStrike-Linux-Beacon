---
phase: 03-reverse-tcp-transport
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - CustomBeacon.cna
  - generate-payload/InsertListenerInfo.py
autonomous: true
requirements:
  - NET-02

must_haves:
  truths:
    - "Operator sees all listener types (including TCP) in the Aggressor dialog — drow_listener (not drow_listener_stage)"
    - "Dialog description reads: 'Supports HTTP, HTTPS, and TCP listeners'"
    - "Generating with a reverse_tcp listener produces a TCP-mode implant — operator makes no additional selections"
    - "Generating with reverse_http or reverse_https works as before"
    - "Selecting an unsupported listener type shows: 'Only reverse_http, reverse_https, and reverse_tcp are supported.'"
    - "CS console logs [Transport: http], [Transport: https], or [Transport: tcp] at generation start"
    - "If Profile Path is non-default and TCP listener selected, CS console logs [TCP MODE] Profile path ignored"
    - "Success message includes transport mode: 'TCP implant generated at ...' vs generic message for HTTP/S"
    - "InsertListenerInfo.py accepts transport_mode string ('http'/'https'/'tcp') — old 0/1 int arg is rejected by argparse"
    - "TCP mode writes minimal profile_config.h (server + port only) — no profile JSON loading, no render_profile_header.py invocation"
    - "HTTP/S mode writes full profile_config.h via existing render_profile_header.py — behavior unchanged"
  artifacts:
    - path: "CustomBeacon.cna"
      provides: "Updated Aggressor dialog with drow_listener, transport auto-detection, TCP validation, log messages"
    - path: "generate-payload/InsertListenerInfo.py"
      provides: "Migrated to transport_mode string arg; TCP path writes minimal profile_config.h"
  key_links:
    - from: "CustomBeacon.cna genPayload callback"
      to: "generate-payload/InsertListenerInfo.py"
      via: "exec() call omits profile_path when transportMode == tcp"
      pattern: "InsertListenerInfo\\.py.*tcp"
    - from: "generate-payload/InsertListenerInfo.py"
      to: "implant/generated/profile_config.h"
      via: "TCP path writes minimal header; HTTP/S path calls render_profile_header.py"
---

<objective>
Update the generation layer — Aggressor CNA and InsertListenerInfo.py — to support TCP transport selection.

This plan is independent of the C layer (Plan 01) and can run in parallel. No C files are touched.

The CNA changes: switch drow_listener_stage to drow_listener, add reverse_tcp to validation, derive $transportMode string from listener type, log [Transport: X] to console, warn on TCP with non-default profile, use new InsertListenerInfo.py call signature (omit profile arg for TCP), pass TRANSPORT=tcp to make for TCP builds, and update success message.

The InsertListenerInfo.py changes: clean break — replace https_value: int with transport_mode: str in argparse, add TCP path that writes a minimal profile_config.h (server + port only), derive use_https from transport_mode for HTTP/S path.

Purpose: After this plan, an operator can select a TCP listener in the Aggressor dialog and receive a correct TCP build without manual script invocation.

Output: Updated CustomBeacon.cna and generate-payload/InsertListenerInfo.py.
</objective>

<execution_context>
@/Users/maleick/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maleick/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-reverse-tcp-transport/03-CONTEXT.md
@.planning/phases/03-reverse-tcp-transport/03-RESEARCH.md

<interfaces>
<!-- Current CNA state (key sections that change) -->

From CustomBeacon.cna — current dialog and validation (to be replaced):
```
# Dialog row (line ~26):
drow_listener_stage($dialog, "listener", "Listener: ");
dialog_description($dialog, "Creates a custom Beacon implant\n- Currently only supports HTTP/S listeners");

# genPayload validation block (to replace):
$HTTPSvalue = "0";
$ListenerName = $3['listener'];
$payloadType = listener_info($ListenerName, "payload");
if ($payloadType ne "windows/beacon_http/reverse_http" && $payloadType ne "windows/beacon_https/reverse_https") {
    show_message("This is an invalid listener type for the Linux Beacon! Only reverse_http and reverse_https are supported.");
    return;
} else if ($payloadType eq "windows/beacon_http/reverse_http") {
    $HTTPSvalue = "0";
} else {
    $HTTPSvalue = "1";
}
# InsertListenerInfo.py invocation (old format):
$command = "python3 InsertListenerInfo.py " . $TargetServer . " " . $TargetPort . " " . $HTTPSvalue . " " . $ProfilePath;

# Success message (to update):
show_message("Your custom implant has been generated at " . $CustomBeaconProjectFolder . "/implant/bin/" . $filename);
```

From generate-payload/InsertListenerInfo.py — current interface (to replace):
```python
def insert_listener_info(target_server: str, target_port: int, https_value: int, profile_path: pathlib.Path) -> int:
    # Loads profile, overlays host/port/use_https, runs validate+render

def parse_args(argv):
    parser.add_argument("https_value", type=int, choices=[0, 1])
    parser.add_argument("profile_path", nargs="?", default=str(DEFAULT_PROFILE))
```

Generated file location:
```
GENERATED_DIR = REPO_ROOT / "implant/generated"
GENERATED_HEADER_PATH = GENERATED_DIR / "profile_config.h"
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update CustomBeacon.cna — drow_listener, transport detection, validation, log messages</name>
  <files>
    CustomBeacon.cna
  </files>
  <action>
Make the following changes to CustomBeacon.cna. Read the current file first, then apply each change precisely.

**Change 1: Dialog row (in genBeaconMenu sub)**

Replace:
```
drow_listener_stage($dialog, "listener", "Listener: ");
dialog_description($dialog, "Creates a custom Beacon implant\n- Currently only supports HTTP/S listeners");
```

With:
```
drow_listener($dialog, "listener", "Listener: ");
dialog_description($dialog, "Creates a custom Beacon implant\n- Supports HTTP, HTTPS, and TCP listeners");
```

Note: drow_listener shows ALL listener types including stageless and TCP. drow_listener_stage only shows staged listeners.

**Change 2: Replace the genPayload transport detection/validation block**

Remove the entire $HTTPSvalue block through the first $command assignment. Replace with:

```
$ListenerName  = $3['listener'];
$payloadType   = listener_info($ListenerName, "payload");
$TargetServer  = listener_info($ListenerName, "host");
$TargetPort    = listener_info($ListenerName, "port");

# Derive transport mode from listener type — no explicit dropdown needed
if ($payloadType eq "windows/beacon_http/reverse_http") {
    $transportMode = "http";
} else if ($payloadType eq "windows/beacon_https/reverse_https") {
    $transportMode = "https";
} else if ($payloadType eq "windows/beacon_tcp/reverse_tcp") {
    $transportMode = "tcp";
} else {
    show_message("Only reverse_http, reverse_https, and reverse_tcp are supported.");
    return;
}

blog($1, "[Transport: $transportMode]");

# Warn if profile path is non-default but TCP is selected (profile unused in TCP mode)
if ($transportMode eq "tcp" && $ProfilePath ne "../profiles/http/default-profile.json") {
    blog($1, "[TCP MODE] Profile path ignored — TCP transport does not use HTTP profiles");
}

# Build InsertListenerInfo.py command — omit profile_path entirely for TCP
if ($transportMode eq "tcp") {
    $command = "python3 InsertListenerInfo.py " . $TargetServer . " " . $TargetPort . " tcp";
} else {
    $command = "python3 InsertListenerInfo.py " . $TargetServer . " " . $TargetPort . " " . $transportMode . " " . $ProfilePath;
}
```

Also remove the old standalone $TargetServer and $TargetPort lines if they appear elsewhere after the validation block (they are now set in the new block above).

**Change 3: Pass TRANSPORT flag to make for TCP builds**

Find the two make command lines (make clean and make build). Add a transport flag variable before them:

```
# Pass TRANSPORT=tcp to Makefile for TCP builds
$makeTransportFlag = "";
if ($transportMode eq "tcp") {
    $makeTransportFlag = " TRANSPORT=tcp";
}

$command = "make clean -f Makefile OUTPUT=" . $filename . $makeTransportFlag;
```

Apply the same $makeTransportFlag suffix to the second make command (without clean).

**Change 4: Transport-aware success message**

Replace the final show_message call:

```
if ($transportMode eq "tcp") {
    show_message("TCP implant generated at " . $CustomBeaconProjectFolder . "/implant/bin/" . $filename);
} else {
    show_message("Your custom implant has been generated at " . $CustomBeaconProjectFolder . "/implant/bin/" . $filename);
}
```

Do NOT change the InsertPublicKey.py / RemovePublicKey.py calls — they apply equally to TCP builds.
  </action>
  <verify>
    <automated>grep -n "drow_listener\b\|transportMode\|Transport:\|TCP MODE\|reverse_tcp\|Supports HTTP, HTTPS\|TRANSPORT=tcp" /opt/CobaltStrike-Linux-Beacon/CustomBeacon.cna</automated>
  </verify>
  <done>CustomBeacon.cna uses drow_listener (not drow_listener_stage). Dialog description says "Supports HTTP, HTTPS, and TCP listeners". genPayload derives $transportMode from $payloadType. Validation accepts reverse_tcp. Error message matches CONTEXT exactly. [Transport: X] and [TCP MODE] log calls present. TCP command omits profile_path arg. TRANSPORT=tcp passed to make for TCP builds. Success message is transport-aware.</done>
</task>

<task type="auto">
  <name>Task 2: Update InsertListenerInfo.py — clean break to transport_mode string, TCP minimal header</name>
  <files>
    generate-payload/InsertListenerInfo.py
  </files>
  <action>
Rewrite generate-payload/InsertListenerInfo.py. Read the current file first, then replace the entire contents with the following. The only external behavior changes are: (1) parse_args now takes transport_mode string instead of https_value int, (2) TCP path writes minimal profile_config.h.

```python
#!/usr/bin/env python3
"""Resolve listener values into a selected profile and render generated config.

New call signature (transport_mode string replaces old 0/1 https_value int):
  python3 InsertListenerInfo.py <host> <port> <transport_mode> [<profile_path>]

transport_mode: "http" | "https" | "tcp"
profile_path:   optional; used for http/https; OMITTED (not empty string) for tcp.

TCP mode writes a minimal profile_config.h (server + port only).
HTTP/S mode writes full profile_config.h via render_profile_header.py (unchanged path).

NOTE: Old callers using 0/1 integer for https_value will get an argparse error.
The CustomBeacon.cna is the only caller and is updated atomically in the same phase.
"""

from __future__ import annotations

import argparse
import json
import pathlib
import subprocess
import sys
from typing import Any, Dict

from validate_profile import validate_profile

THIS_DIR = pathlib.Path(__file__).resolve().parent
REPO_ROOT = THIS_DIR.parent
DEFAULT_PROFILE = REPO_ROOT / "profiles/http/default-profile.json"
GENERATED_DIR = REPO_ROOT / "implant/generated"
SELECTED_PROFILE_PATH = GENERATED_DIR / "selected_profile.json"
GENERATED_HEADER_PATH = GENERATED_DIR / "profile_config.h"

# Minimal TCP profile_config.h template — only server and port needed for TCP transport.
# No URI, user-agent, headers, or HTTPS flag — TCP has no HTTP profile concept.
_TCP_HEADER_TEMPLATE = (
    "/* profile_config.h -- TCP transport (minimal: server and port only)\n"
    " * Generated by InsertListenerInfo.py for transport_mode=tcp.\n"
    " * No HTTP profile fields apply to TCP transport.\n"
    " */\n"
    "#ifndef PROFILE_CONFIG_H\n"
    "#define PROFILE_CONFIG_H\n"
    "\n"
    '#define PROFILE_C2_SERVER "{server}"\n'
    "#define PROFILE_C2_PORT   {port}\n"
    "\n"
    "#endif /* PROFILE_CONFIG_H */\n"
)


def _resolve_path(raw: str) -> pathlib.Path:
    candidate = pathlib.Path(raw)
    if candidate.is_absolute():
        return candidate
    return (THIS_DIR / candidate).resolve()


def _load_profile(path: pathlib.Path) -> Dict[str, Any]:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except FileNotFoundError as exc:
        raise ValueError(f"profile file not found: {path}") from exc
    except json.JSONDecodeError as exc:
        raise ValueError(f"invalid profile JSON at {path}: {exc}") from exc


def _write_selected_profile(profile: Dict[str, Any], output_path: pathlib.Path) -> None:
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(json.dumps(profile, indent=2, sort_keys=True) + "\n", encoding="utf-8")


def _write_tcp_config_header(target_server: str, target_port: int) -> None:
    """Write minimal profile_config.h for TCP builds -- no profile file involved."""
    GENERATED_DIR.mkdir(parents=True, exist_ok=True)
    content = _TCP_HEADER_TEMPLATE.format(server=target_server, port=target_port)
    GENERATED_HEADER_PATH.write_text(content, encoding="utf-8")
    print(f"Generated TCP config header: {GENERATED_HEADER_PATH}")


def insert_listener_info(
    target_server: str,
    target_port: int,
    transport_mode: str,
    profile_path: pathlib.Path | None = None,
) -> int:
    if transport_mode == "tcp":
        # TCP mode: write minimal header only -- no profile loading, no validation, no render
        _write_tcp_config_header(target_server, target_port)
        print("Transport mode: tcp -- profile skipped")
        return 0

    # HTTP/S mode: existing profile load -> validate -> render path
    if profile_path is None:
        profile_path = DEFAULT_PROFILE

    profile = _load_profile(profile_path)

    profile["host"] = target_server
    profile["port"] = int(target_port)
    profile["use_https"] = transport_mode == "https"

    _write_selected_profile(profile, SELECTED_PROFILE_PATH)

    _, errors = validate_profile(SELECTED_PROFILE_PATH)
    if errors:
        for error in errors:
            print(f"INVALID {SELECTED_PROFILE_PATH}: {error}")
        return 1

    render_cmd = [
        sys.executable,
        str(THIS_DIR / "render_profile_header.py"),
        "--profile",
        str(SELECTED_PROFILE_PATH),
        "--output",
        str(GENERATED_HEADER_PATH),
    ]
    subprocess.run(render_cmd, check=True)

    print(f"Profile selection resolved: source={profile_path}")
    print(f"Generated profile JSON: {SELECTED_PROFILE_PATH}")
    print(f"Generated profile header: {GENERATED_HEADER_PATH}")
    return 0


def parse_args(argv: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Inject listener values into selected profile artifact",
        epilog=(
            "transport_mode replaces the old 0/1 https_value integer argument. "
            "profile_path is omitted (not passed as empty string) when transport_mode is tcp."
        ),
    )
    parser.add_argument("target_server")
    parser.add_argument("target_port", type=int)
    parser.add_argument("transport_mode", choices=["http", "https", "tcp"])
    parser.add_argument("profile_path", nargs="?", default=None)
    return parser.parse_args(argv)


def main(argv: list[str]) -> int:
    args = parse_args(argv)
    profile_path = _resolve_path(args.profile_path) if args.profile_path is not None else None

    try:
        return insert_listener_info(
            args.target_server,
            args.target_port,
            args.transport_mode,
            profile_path,
        )
    except (OSError, ValueError, subprocess.CalledProcessError) as exc:
        print(f"ERROR InsertListenerInfo: {exc}")
        return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
```

Key behavioral differences from the old version:
- parse_args: https_value int choices=[0,1] replaced by transport_mode str choices=["http","https","tcp"]
- insert_listener_info: https_value int param replaced by transport_mode str; TCP path added
- profile["use_https"] = bool(int(https_value)) replaced by profile["use_https"] = transport_mode == "https"
- profile_path defaults to None (resolved inside function for HTTP/S; irrelevant for TCP)
  </action>
  <verify>
    <automated>cd /opt/CobaltStrike-Linux-Beacon/generate-payload && python3 InsertListenerInfo.py --help 2>&1 && python3 InsertListenerInfo.py 10.0.0.1 4444 tcp 2>&1</automated>
  </verify>
  <done>InsertListenerInfo.py --help shows transport_mode with choices [http, https, tcp]. python3 InsertListenerInfo.py 10.0.0.1 4444 tcp exits 0 and writes a minimal profile_config.h to implant/generated/ containing PROFILE_C2_SERVER and PROFILE_C2_PORT. Old 0/1 int args are rejected by argparse with a clear error message.</done>
</task>

</tasks>

<verification>
1. grep "drow_listener\b" /opt/CobaltStrike-Linux-Beacon/CustomBeacon.cna — must show drow_listener not drow_listener_stage
2. grep "reverse_tcp\|transportMode\|TCP MODE\|Transport:" /opt/CobaltStrike-Linux-Beacon/CustomBeacon.cna — all four must appear
3. cd /opt/CobaltStrike-Linux-Beacon/generate-payload && python3 InsertListenerInfo.py 10.0.0.1 4444 0 2>&1 — must fail with argparse invalid choice: '0'
4. cd /opt/CobaltStrike-Linux-Beacon/generate-payload && python3 InsertListenerInfo.py 10.0.0.1 4444 tcp 2>&1 — must succeed and create implant/generated/profile_config.h
5. cat /opt/CobaltStrike-Linux-Beacon/implant/generated/profile_config.h — TCP header must contain PROFILE_C2_SERVER "10.0.0.1" and PROFILE_C2_PORT 4444
</verification>

<success_criteria>
- CustomBeacon.cna: drow_listener (all listener types visible), transport auto-derived from payloadType, reverse_tcp supported, old validation replaced, [Transport: X] logged, [TCP MODE] warning on profile mismatch, TCP invocation omits profile path, TRANSPORT=tcp passed to make, transport-aware success message
- InsertListenerInfo.py: transport_mode string replaces https_value int, argparse choices=["http","https","tcp"], TCP path writes minimal profile_config.h with server+port only, HTTP/S path unchanged, old int arg rejected
</success_criteria>

<output>
After completion, create `.planning/phases/03-reverse-tcp-transport/03-02-SUMMARY.md`
</output>
