---
phase: 03-reverse-tcp-transport
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [implant/Makefile, implant/headers/beacon.h, implant/src/beacon.c, implant/src/http.c]
autonomous: true
requirements: [NET-01]
---

<objective>
Implement the C transport abstraction layer and the initial Reverse TCP transport module.

Purpose: Allow the beacon to support multiple transport types (HTTP/S and TCP) through a common interface.
Output: transport.h, tcp.c, refactored http.c, and updated Makefile.
</objective>

<execution_context>
@/Users/maleick/.gemini/get-shit-done/workflows/execute-plan.md
</execution_context>

<tasks>

<task type="auto">
  <name>Task 1: Define transport interface</name>
  <files>implant/headers/transport.h</files>
  <action>
    - Create `implant/headers/transport.h` defining the `transport_t` interface:
      - `int transport_init(beacon_state_t *state);`
      - `int transport_send_metadata(beacon_state_t *state, const uint8_t *data, size_t len);`
      - `int transport_receive_tasks(beacon_state_t *state, uint8_t **tasks, size_t *tasks_len);`
      - `int transport_send_output(beacon_state_t *state, const uint8_t *data, size_t len);`
      - `void transport_cleanup(void);`
  </action>
  <verify>
    Check for existence of header file.
  </verify>
  <done>transport.h defines a clean abstraction for C2 communication.</done>
</task>

<task type="auto">
  <name>Task 2: Implement HTTP transport module</name>
  <files>implant/src/http.c, implant/headers/http.h</files>
  <action>
    - Refactor `http.c` to implement the `transport_t` interface.
    - Preserve existing CURL-based logic for GET/POST.
    - Ensure `http_response_t` and other internals are appropriately scoped.
  </action>
  <verify>
    make -C implant TRANSPORT=http
  </verify>
  <done>HTTP transport is now a pluggable module.</done>
</task>

<task type="auto">
  <name>Task 3: Implement TCP transport module</name>
  <files>implant/src/tcp.c, implant/headers/tcp.h</files>
  <action>
    - Create `implant/src/tcp.c` implementing the Reverse TCP protocol:
      - Standard socket connection to `PROFILE_C2_SERVER:PROFILE_C2_PORT`.
      - Send metadata immediately upon connection (standard for Reverse TCP).
      - Receive tasks: [4 bytes length][N bytes encrypted task data].
      - Send output: [4 bytes length][N bytes encrypted output data].
    - Use standard POSIX socket APIs.
  </action>
  <verify>
    make -C implant TRANSPORT=tcp
  </verify>
  <done>TCP transport module is implemented.</done>
</task>

<task type="auto">
  <name>Task 4: Update Makefile and beacon.c</name>
  <files>implant/Makefile, implant/src/beacon.c</files>
  <action>
    - Update `implant/Makefile` to support `TRANSPORT` variable (defaults to `http`).
    - Selectively compile `http.c` or `tcp.c` based on the variable.
    - Add `-DTRANSPORT_HTTP` or `-DTRANSPORT_TCP` to CFLAGS.
    - Refactor `beacon_checkin` and `beacon_send_output` in `beacon.c` to use the `transport_*` functions.
  </action>
  <verify>
    make -C implant TRANSPORT=http
    make -C implant TRANSPORT=tcp
  </verify>
  <done>Beacon core is transport-agnostic and Makefile supports switching transports.</done>
</task>

</tasks>

<verification>
Successful compilation of both HTTP and TCP versions of the beacon.
</verification>

<success_criteria>
1. transport.h interface is defined and used by beacon.c.
2. make TRANSPORT=http produces a working HTTP beacon (build verified).
3. make TRANSPORT=tcp produces a working TCP beacon (build verified).
</success_criteria>

<output>
After completion, create `.planning/phases/03-reverse-tcp-transport/03-01-SUMMARY.md`
</output>
